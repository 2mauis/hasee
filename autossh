
void  Motor1_Postion_Init()
	{ 
	//while((m_Status_Speed_Flag[MOTOR2])+m_Status_Speed_Flag[MOTOR3]+m_Status_Speed_Flag[MOTOR4])!=3*STATUS_STOP);  //等待其他电机初始化完成
	m_Step_Count[MOTOR1]=0;	
	TIM1->ARR=m_ArrMax[MOTOR1];//设置为最慢速度
	TIM_ClearFlag(TIM1,TIM_IT_CC1);
	TIM_ITConfig( TIM1, TIM_IT_CC1,ENABLE);
	Motor1_Direction_Control(MOTOR_DIR_BACKWARD);
	TIM_Cmd(TIM1,ENABLE);
	

	//  { GPIOD->IDR&GPIO_Pin_0	
	while(GPIOD->IDR&GPIO_Pin_0)//等待到达零点
	      {
      		if (m_Step_Count[MOTOR1]>m_Status_Relative_Step[MOTOR1])//等待超时释放电机  返回等待处理  
			{   Motor_Free(MOTOR1); 
				TIM_Cmd(TIM1,DISABLE);
			
			 SETB(m_Positon_Init_Flag,0);//设置位置初始化失败标志.
			 return ; //退出初始化过程
			}
        	}
	
   	Motor1_Direction_Control(MOTOR_DIR_FORWARD);	
   	m_Step_Count[MOTOR1]=0;//清空位置步数统计

	while(GPIOD->IDR&GPIO_Pin_1)//等待到达最大位置
		{
  			if ( m_Step_Count[MOTOR1]>m_Status_Relative_Step_Max[MOTOR1]) //大于预给定的最大  步数 等待超时
  			{
			Motor_Free( MOTOR1) ; //失能电机
			TIM_Cmd(TIM1,DISABLE);
			 SETB(m_Positon_Init_Flag,0);//设置位置初始化失败标志.
			 return ; //退出初始化过程
			}
  		}
	
	m_Relative_Step_Max[MOTOR1]=m_Step_Count[MOTOR1];  //更新最大位置以及当前最大位置
	m_Status_Relative_Step[MOTOR1]=m_Step_Count[MOTOR1];//更新当前位置 
    	m_Step_Count[MOTOR1]=0; //清空计数值
     	Motor1_Direction_Control(MOTOR_DIR_FORWARD);
       while(m_Step_Count[MOTOR1]<m_Status_Relative_Step_Max[MOTOR1]);//返回零点
      	Motor_Free(MOTOR1); 	//失能电机
	TIM_Cmd(TIM1,DISABLE);
	TIM_ITConfig( TIM1, TIM_IT_CC1,DISABLE);//失能中断
	m_Step_Count[MOTOR1]=0
	CLRB(m_Positon_Init_Flag,0);   // 设置位置初始化成功标志  
 	
